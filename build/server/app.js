// Generated by CoffeeScript 1.6.3
(function() {
  var async, blad, configureApp, connect, crypto, director, eco, flatiron, fs, mongodb, path, union, utils, winston,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  flatiron = require('flatiron');

  union = require('union');

  director = require('director');

  winston = require('winston');

  connect = require('connect');

  mongodb = require('mongodb');

  eco = require('eco');

  async = require('async');

  crypto = require('crypto');

  fs = require('fs');

  path = require('path');

  utils = require('./utils.js');

  exports.db = utils.db;

  exports.blad = exports.blaÃ° = blad = require('./blad.js');

  configureApp = function(_arg) {
    var app, config, db, expose, file, log, obj, p, routes, url, _i, _len, _ref, _ref1;
    config = _arg.config, log = _arg.log;
    app = flatiron.app;
    app.use(flatiron.plugins.http, {
      'before': config.middleware.concat([
        connect.favicon(), connect["static"](__dirname + '/../public'), function(req, res, next) {
          var _ref;
          if (req.url.match(new RegExp("^/api", 'i'))) {
            if (req.headers['x-blad-apikey'] == null) {
              res.writeHead(403);
              res.write('`X-Blad-ApiKey` needs to be provided in headers of all API requests');
              return res.end();
            } else {
              if (_ref = req.headers['x-blad-apikey'], __indexOf.call(config.browserid.hashes, _ref) >= 0) {
                return next();
              } else {
                res.writeHead(403);
                res.write('Invalid `X-Blad-ApiKey` authorization');
                return res.end();
              }
            }
          } else {
            return next();
          }
        }
      ]),
      'onError': function(err, req, res) {
        log.error(err.message);
        if (err.status === 404 && (req.url.match(new RegExp("^/admin", 'i')) != null)) {
          return res.redirect('/admin', 301);
        } else {
          return union.errorHandler(err, req, res);
        }
      }
    });
    app.use({
      name: 'eco-templating',
      attach: function(options) {
        return app.eco = function(file, data, cb) {
          return fs.readFile(path.join(config.site_src, "/src/types/" + file + ".eco"), 'utf8', function(err, template) {
            if (err) {
              return cb(err);
            } else {
              try {
                return cb(null, eco.render(template, data));
              } catch (_error) {
                err = _error;
                return cb(err);
              }
            }
          });
        };
      }
    });
    db = null;
    app.use({
      name: 'mongodb',
      attach: function(options) {
        return app.db = function(done) {
          var collection;
          collection = function(done) {
            return db.collection(config.env, function(err, coll) {
              if (err) {
                throw err;
              }
              return done(coll);
            });
          };
          if (db == null) {
            log.debug('Connect to MongoDB');
            return mongodb.Db.connect(config.mongodb, function(err, connection) {
              var mcfg;
              if (err) {
                throw err;
              }
              mcfg = connection.serverConfig;
              log.info('Connected to ' + ("mongodb://" + mcfg.host + ":" + mcfg.port + "/" + mcfg.db.databaseName).bold);
              db = connection;
              return collection(done);
            });
          } else {
            return collection(done);
          }
        };
      }
    });
    expose = {
      'config': config,
      'log': log,
      'blad': blad,
      'app': app
    };
    routes = {};
    p = "" + __dirname + "/routes";
    _ref = fs.readdirSync(p);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      file = _ref[_i];
      _ref1 = require("" + p + "/" + file)(expose);
      for (url in _ref1) {
        obj = _ref1[url];
        routes[url] = obj;
      }
    }
    app.router = new director.http.Router(routes);
    return app;
  };

  exports.start = function(cfg, site_src, done) {
    var compile, config, fin, include, log, map, readConfig, startApp, validateConfig, welcome;
    config = {};
    log = null;
    config.site_src = site_src;
    readConfig = function(cb) {
      var err, key, value, _ref;
      log.debug('Duplicate config');
      try {
        _ref = JSON.parse(JSON.stringify(cfg));
        for (key in _ref) {
          value = _ref[key];
          config[key] = value;
        }
        return cb(null);
      } catch (_error) {
        err = _error;
        return cb(err);
      }
    };
    startApp = function(cb) {
      var app;
      log.debug('Setup & start ' + 'flatiron'.grey);
      app = configureApp({
        'config': config,
        'log': log
      });
      return app.start(config.port, function(err) {
        if (err) {
          return cb(err);
        } else {
          return cb(null, app);
        }
      });
    };
    welcome = function(cb) {
      return async.parallel([
        function(_cb) {
          var err;
          try {
            return _cb(null, require("" + __dirname + "/../../package.json"));
          } catch (_error) {
            err = _error;
            return _cb(err);
          }
        }, async.apply(fs.readFile, "" + __dirname + "/../../logo.txt", 'utf8')
      ], function(err, _arg) {
        var line, logo, pkg, _i, _len, _ref, _ref1;
        pkg = _arg[0], logo = _arg[1];
        if (err) {
          return cb(err);
        } else {
          if (typeof pkg !== 'object') {
            _ref = [pkg, logo], logo = _ref[0], pkg = _ref[1];
          }
          log.info('Welcome to ' + ("blad " + pkg.version).grey);
          _ref1 = logo.split('\n');
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            line = _ref1[_i];
            log.help(line.cyan.bold);
          }
          log.help('');
          log.help('A forms based Node.js CMS');
          log.help('');
          return cb(null);
        }
      });
    };
    validateConfig = function(cb) {
      var email, err, suffix, use, _i, _len, _ref;
      log.debug('Validate config');
      config.mongodb = process.env.MONGO_URL || process.env.DATABASE_URL || config.mongodb;
      config.port = process.env.PORT || config.port;
      config.env = process.env.NODE_ENV || 'documents';
      if (config.browserid == null) {
        config.browserid = {};
      }
      config.browserid.salt = process.env.API_SALT || config.browserid.salt;
      if (config.middleware == null) {
        config.middleware = [];
      }
      if ((config.browserid == null) || (config.browserid.provider == null) || (config.browserid.salt == null) || (config.browserid.users == null) || !config.browserid.users instanceof Array) {
        return cb('You need to create a valid `browserid` section');
      }
      if (config.mongodb == null) {
        return cb('You need to specify the `mongodb` uri');
      }
      config.browserid.hashes = [];
      _ref = config.browserid.users;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        email = _ref[_i];
        config.browserid.hashes.push(crypto.createHash('md5').update(email + config.browserid.salt).digest('hex'));
      }
      use = function(pkg) {
        switch (pkg) {
          case 'connect-baddies':
            return require(pkg)();
          default:
            throw new Error("Unknown middleware `" + pkg + "`");
        }
      };
      try {
        config.middleware = (function() {
          var _j, _len1, _ref1, _results;
          _ref1 = config.middleware;
          _results = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            suffix = _ref1[_j];
            _results.push(use('connect-' + suffix));
          }
          return _results;
        })();
        return cb(null);
      } catch (_error) {
        err = _error;
        return cb(err);
      }
    };
    compile = function(cb) {
      log.debug('Build site code');
      utils.log(function(message) {
        return log.data(message);
      });
      return async.waterfall([utils.compile.admin, utils.compile.forms(config), utils.copy["public"](config), utils.copy.additions(config), utils.include.presenters(config)], function(err, presenters) {
        if (err) {
          return cb(err);
        } else {
          return cb(null, presenters);
        }
      });
    };
    include = function(presenters, cb) {
      var f, key, p, req, _i, _len;
      log.debug('Including custom presenters: ' + ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = presenters.length; _i < _len; _i++) {
          f = presenters[_i];
          _results.push((p = f.split('/'), p[p.length - 2]));
        }
        return _results;
      })()).join(', '));
      for (_i = 0, _len = presenters.length; _i < _len; _i++) {
        f = presenters[_i];
        req = require(f);
        key = Object.keys(req)[0];
        blad.types[key] = req[key];
      }
      return cb(null);
    };
    map = function(app, cb) {
      log.debug('Map existing documents');
      return app.db(function(collection) {
        return collection.find({
          'public': true
        }).toArray(function(err, docs) {
          var doc, _i, _len;
          if (err) {
            return cb(err);
          } else {
            for (_i = 0, _len = docs.length; _i < _len; _i++) {
              doc = docs[_i];
              log.info('Mapping url ' + doc.url.underline);
              app.router.path(doc.url, blad.get);
            }
            return cb(null, app);
          }
        });
      });
    };
    fin = function(err, app) {
      var e;
      if (err) {
        try {
          err = JSON.parse(err);
          return log.error(err.error.message || err.message || err);
        } catch (_error) {
          e = _error;
          return log.error(err);
        }
      } else {
        log.debug('Done');
        log.info('Listening on port ' + app.server.address().port.toString().bold);
        log.info('blad'.grey + ' started ' + 'ok'.green.bold);
        if (done && typeof done === 'function') {
          return done(app);
        }
      }
    };
    if (process.env.NODE_ENV !== 'test') {
      winston.cli();
      winston.add(winston.transports.File, {
        'filename': "" + __dirname + "/../../blad.log"
      });
      log = winston;
      return async.waterfall([welcome, readConfig, validateConfig, compile, include, startApp, map], fin);
    } else {
      winston.loggers.add('dummy', {
        'console': {
          'silent': true
        }
      });
      log = winston.loggers.get('dummy');
      return async.waterfall([readConfig, startApp], fin);
    }
  };

}).call(this);
